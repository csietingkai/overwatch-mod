package com.tingkai.overwatch.items.armors;

import java.util.HashMap;
import java.util.List;
import java.util.UUID;

import javax.annotation.Nullable;

import com.google.common.collect.Maps;
import com.tingkai.overwatch.Config;
import com.tingkai.overwatch.Overwatch;
import com.tingkai.overwatch.command.CommandDev;
import com.tingkai.overwatch.hero.Ability;
import com.tingkai.overwatch.hero.EnumHeros;
import com.tingkai.overwatch.key.Keys;
import com.tingkai.overwatch.key.Keys.KeyBind;
import com.tingkai.overwatch.messages.SPacketSyncAbilityUses;

import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityItem;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.ItemArmor;
import net.minecraft.item.ItemStack;
import net.minecraft.util.text.TextFormatting;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.PlayerEvent.PlayerLoggedInEvent;
import net.minecraftforge.fml.common.gameevent.PlayerEvent.PlayerRespawnEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import net.minecraftforge.fml.common.gameevent.TickEvent;

public class ItemOWArmor extends ItemArmor
{
	public EnumHeros heros;

	public static final EntityEquipmentSlot[] SLOTS = new EntityEquipmentSlot[]
	{ EntityEquipmentSlot.HEAD, EntityEquipmentSlot.CHEST, EntityEquipmentSlot.LEGS, EntityEquipmentSlot.FEET };

	public ItemOWArmor(ArmorMaterial materialIn, int renderIndexIn, EntityEquipmentSlot equipmentSlotIn, EnumHeros heros)
	{
		super(materialIn, renderIndexIn, equipmentSlotIn);
		this.heros = heros;
	}

	@Override
	@Nullable
	public String getArmorTexture(ItemStack stack, Entity entity, EntityEquipmentSlot slot, String type)
	{
		String re = Overwatch.MODID;
		re += ":textures/models/armor/" + heros.name.toLowerCase() + "_" + heros.textureVariation + "_layer_";
		if (slot == EntityEquipmentSlot.LEGS)
		{
			re += 2;
		}
		else
		{
			re += 1;
		}
		re += ".png";
		return re;
	}

	@Mod.EventBusSubscriber
	public static class SetManager
	{
		public static HashMap<UUID, EnumHeros> playersWearingSets = Maps.newHashMap();
		public static HashMap<UUID, EnumHeros> lastWornSets = Maps.newHashMap();

		@SubscribeEvent
		public static void resetCooldowns(PlayerLoggedInEvent event)
		{
			for (KeyBind keybind : Keys.KeyBind.values())
			{
				if (keybind.getCooldown(event.player) > 0)
				{
					keybind.setCooldown(event.player, 0);
				}
			}
			for (EnumHeros hero : EnumHeros.values())
			{
				for (Ability ability : new Ability[]
				{ hero.ability1, hero.ability2, hero.ability3 })
				{
					if (ability.multiAbilityUses.remove(event.player.getPersistentID()) != null && event.player instanceof EntityPlayerMP)
					{
						Overwatch.network.sendTo(new SPacketSyncAbilityUses(event.player.getPersistentID(), hero, ability.getNumber(), ability.maxUse), (EntityPlayerMP) event.player);
					}
				}
			}
		}

		@SubscribeEvent
		public static void resetCooldowns(PlayerRespawnEvent event)
		{
			for (KeyBind keybind : Keys.KeyBind.values())
			{
				if (keybind.getCooldown(event.player) > 0)
				{
					keybind.setCooldown(event.player, 0);
				}
			}
		}

		@SubscribeEvent
		public static void updateSets(TickEvent.PlayerTickEvent event)
		{
			if (event.phase == TickEvent.Phase.START)
			{
				ItemStack stack = event.player.getItemStackFromSlot(EntityEquipmentSlot.HEAD);
				EnumHeros hero = null;
				boolean full = stack != null && stack.getItem() instanceof ItemOWArmor;
				if (full)
				{
					hero = ((ItemOWArmor) stack.getItem()).heros;
					for (EntityEquipmentSlot slot : SLOTS)
					{
						ItemStack armor = event.player.getItemStackFromSlot(slot);
						if (armor == null || !(armor.getItem() instanceof ItemOWArmor) || ((ItemOWArmor) (armor.getItem())).heros != hero)
						{
							full = false;
						}
					}
				}

				if (hero != null && (event.player.getHeldItemMainhand() == null || event.player.getHeldItemMainhand().getItem() != hero.weapon) || (full && (!SetManager.playersWearingSets.containsKey(event.player.getPersistentID()) || SetManager.playersWearingSets.get(event.player.getPersistentID()) != hero)))
				{
					for (Ability ability : new Ability[]
					{ hero.ability1, hero.ability2, hero.ability3 })
					{
						ability.toggled.remove(event.player.getPersistentID());
					}
				}

				if (full)
				{
					SetManager.playersWearingSets.put(event.player.getPersistentID(), hero);
					if (SetManager.lastWornSets.get(event.player.getPersistentID()) != hero)
					{
						for (KeyBind key : Keys.KeyBind.values())
						{
							if (key.getCooldown(event.player) > 0)
							{
								key.setCooldown(event.player, 0);
							}
						}
						SetManager.lastWornSets.put(event.player.getPersistentID(), hero);
					}
				}
				else
				{
					SetManager.playersWearingSets.remove(event.player.getPersistentID());
				}
			}
		}
	}

	@Override
	@SideOnly(Side.CLIENT)
	public void addInformation(ItemStack stack, EntityPlayer player, List<String> tooltip, boolean advanced)
	{
		if (stack.hasTagCompound() && stack.getTagCompound().hasKey("devSpawned"))
		{
			tooltip.add(TextFormatting.DARK_BLUE + "" + TextFormatting.BOLD + "Dev Spawned");
		}
		super.addInformation(stack, player, tooltip, advanced);
	}

	@Override
	public void onUpdate(ItemStack stack, World world, Entity entity, int slot, boolean isSelected)
	{
		if (!world.isRemote && entity instanceof EntityPlayer && stack.hasTagCompound() && stack.getTagCompound().hasKey("devSpawned") && !CommandDev.DEVS.contains(entity.getPersistentID()) && ((EntityPlayer) entity).inventory.getStackInSlot(slot) == stack)
		{
			((EntityPlayer) entity).inventory.setInventorySlotContents(slot, ItemStack.EMPTY);
			return;
		}

		if (Config.durabilityOptionArmors == 2 && stack.getItemDamage() != 0)
		{
			stack.setItemDamage(0);
		}

		super.onUpdate(stack, world, entity, slot, isSelected);
	}

	@Override
	public boolean onEntityItemUpdate(EntityItem entityItem)
	{
		if (!entityItem.world.isRemote && entityItem != null && entityItem.getEntityItem() != null && entityItem.getEntityItem().hasTagCompound() && entityItem.getEntityItem().getTagCompound().hasKey("devSpawned"))
		{
			entityItem.setDead();
			return true;
		}
		return false;
	}

	@Override
	public void onArmorTick(World world, EntityPlayer player, ItemStack stack)
	{
		if (stack.isEmpty() || (!world.isRemote && stack.hasTagCompound() && stack.getTagCompound().hasKey("devSpawned") && !CommandDev.DEVS.contains(player.getPersistentID()) && player.getItemStackFromSlot(this.armorType) == stack))
		{
			player.setItemStackToSlot(this.armorType, ItemStack.EMPTY);
			return;
		}

		if (this.armorType == EntityEquipmentSlot.CHEST && heros == EnumHeros.TRACER && world.isRemote && player != null && (player.chasingPosX != 0 || player.chasingPosY != 0 || player.chasingPosZ != 0))
		{
			int numParticles = (int) ((Math.abs(player.chasingPosX - player.posX) + Math.abs(player.chasingPosY - player.posY) + Math.abs(player.chasingPosZ - player.posZ)) * 5d);
			for (int i = 0; i < numParticles; ++i)
			{
				Overwatch.proxy.spawnParticlesTrail(player.world, player.posX + (player.chasingPosX - player.posX) * i / numParticles, player.posY + (player.chasingPosY - player.posY) * i / numParticles + player.height / 2 + 0.3f, player.posZ + (player.chasingPosZ - player.posZ) * i / numParticles, 0, 0, 0, 0x5EDCE5, 0x007acc, 1, 7, 1);
			}
		}

		if (!world.isRemote && Config.durabilityOptionArmors == 1 && stack.getItemDamage() != 0 && SetManager.playersWearingSets.get(player.getPersistentID()) == heros)
		{
			stack.setItemDamage(0);
		}
	}
}